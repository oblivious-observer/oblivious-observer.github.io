<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Recovering a forgotten LUKS password | oblivious observer</title><meta name=keywords content="NixOS,LUKS,bash"><meta name=description content="A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!
This is not exactly a new topic, there are nice posts about this problem such as this one, however this is how I&rsquo;ve tried to tackle the problem.
The password was generated according to a couple of rules and only partially lost.
Lets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing."><meta name=author content="oblivious observer"><link rel=canonical href=https://oblivious.observer/posts/recovering-a-lost-password/><link crossorigin=anonymous href=/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css integrity="sha256-DE/TclFxNm8zUVWs3m+zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as=style><link rel=icon href=https://oblivious.observer/observer-16x16.png><link rel=icon type=image/png sizes=16x16 href=https://oblivious.observer/observer-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oblivious.observer/observer-32x32.png><link rel=apple-touch-icon href=https://oblivious.observer/observer-512x512.png><link rel=mask-icon href=https://oblivious.observer/observer-512x512.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://oblivious.observer/css/syntax.css><meta property="og:title" content="Recovering a forgotten LUKS password"><meta property="og:description" content="A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!
This is not exactly a new topic, there are nice posts about this problem such as this one, however this is how I&rsquo;ve tried to tackle the problem.
The password was generated according to a couple of rules and only partially lost.
Lets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing."><meta property="og:type" content="article"><meta property="og:url" content="https://oblivious.observer/posts/recovering-a-lost-password/"><meta property="og:image" content="https://oblivious.observer/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-03T00:00:00+00:00"><meta property="og:site_name" content="oblivious.observer"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://oblivious.observer/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Recovering a forgotten LUKS password"><meta name=twitter:description content="A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!
This is not exactly a new topic, there are nice posts about this problem such as this one, however this is how I&rsquo;ve tried to tackle the problem.
The password was generated according to a couple of rules and only partially lost.
Lets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://oblivious.observer/posts/"},{"@type":"ListItem","position":3,"name":"Recovering a forgotten LUKS password","item":"https://oblivious.observer/posts/recovering-a-lost-password/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Recovering a forgotten LUKS password","name":"Recovering a forgotten LUKS password","description":"A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!\nThis is not exactly a new topic, there are nice posts about this problem such as this one, however this is how I\u0026rsquo;ve tried to tackle the problem.\nThe password was generated according to a couple of rules and only partially lost.\nLets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing.","keywords":["NixOS","LUKS","bash"],"articleBody":"A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!\nThis is not exactly a new topic, there are nice posts about this problem such as this one, however this is how I’ve tried to tackle the problem.\nThe password was generated according to a couple of rules and only partially lost.\nLets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing.\nLets build ourselves a little prototype:\nFirst let’s grab a wordlist, in this case lets grab a copy of the EFFs short word list from here:\n$ wget https://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt --2023-11-03 18:34:27-- https://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt Resolving www.eff.org (www.eff.org)... 2a04:4e42:8d::201, 146.75.116.201 Connecting to www.eff.org (www.eff.org)|2a04:4e42:8d::201|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 13660 (13K) [text/plain] Saving to: ‘eff_short_wordlist_1.txt’ eff_short_wordlist_1.txt 100%[====================================================================================================\u003e] 13.34K --.-KB/s in 0.002s 2023-11-03 18:34:28 (6.58 MB/s) - ‘eff_short_wordlist_1.txt’ saved [13660/13660] $ head eff_short_wordlist_1.txt 1111 acid 1112 acorn 1113 acre 1114 acts 1115 afar 1116 affix 1121 aged 1122 agent 1123 agile 1124 aging $ cat wordlist.txt | wc -l 1296 Taking a look at the wordlist, we can see it contains two columns and is 1.3k lines long, since we are only interested in the words itself and this is an example, lets create a new shorter wordlist file:\n$ shuf -n 100 eff_short_wordlist_1.txt | sort | cut -f 2- \u003e wordlist.txt $ head wordlist.txt aloft arson bagel bunny cache cheer cleat clump comma crush $ cat wordlist.txt | wc -l 100 Now lets generate a file containing all possible passwords according to what we know. We have a couple of words we know and are missing two of them, but we know the positions of the missing words.\nLets grab a couple of words start with so we can generate a test password:\n$ shuf -n 6 wordlist.txt march scoff large drove wavy crush So lets assume our password is the following string with X and Y being the missing words:\nmarch scoff X large drove wavy Y crush Based on this we can quickly generate a list of possible passwords from the wordlist:\ninput_string=\"march scoff X large drove wavy Y crush\" readarray -t words \u003c wordlist.txt for word_x in \"${words[@]}\"; do for word_y in \"${words[@]}\"; do replaced_string=\"${input_string/X/$word_x}\" replaced_string=\"${replaced_string/Y/$word_y}\" echo \"$replaced_string\" done done \u003e password_list This gives us a list with 10000 possible combnations for passphrases.\nHowever we can probably assume, that the forgotten passphrase does not contain the same two words twice, so lets cut it down a bit further:\ninput_string=\"march scoff X large drove wavy Y crush\" readarray -t words \u003c wordlist.txt for word_x in \"${words[@]}\"; do for word_y in \"${words[@]}\"; do replaced_string=\"${input_string/X/$word_x}\" replaced_string=\"${replaced_string/Y/$word_y}\" if [[ \"$word_x\" != \"$word_y\" \u0026\u0026 \"$input_string\" != *\"$word_x\"* \u0026\u0026 \"$input_string\" != *\"$word_y\"* ]]; then echo \"$replaced_string\" fi done done \u003e password_list This way we end up with only 8742 possible words, so we have already eliminated ~13% of possible passwords, nice.\nAt this point we’ve generated every possible combination that makes sense to check, however the word list still looks like this:\n$ head password_list march scoff aloft large drove wavy arson crush march scoff aloft large drove wavy bagel crush march scoff aloft large drove wavy bunny crush march scoff aloft large drove wavy cache crush march scoff aloft large drove wavy cheer crush march scoff aloft large drove wavy cleat crush march scoff aloft large drove wavy clump crush march scoff aloft large drove wavy comma crush march scoff aloft large drove wavy cycle crush march scoff aloft large drove wavy dab crush Lets add some randomness into the mix by shuffling the order around:\n$ shuf password_list \u003e passwords $ head passwords march scoff thud large drove wavy icon crush march scoff deck large drove wavy slimy crush march scoff said large drove wavy slept crush march scoff jet large drove wavy snap crush march scoff penny large drove wavy fiber crush march scoff decoy large drove wavy slept crush march scoff wipe large drove wavy spoon crush march scoff clump large drove wavy recap crush march scoff deck large drove wavy fiber crush march scoff said large drove wavy radar crush This looks way better already, now a script running through every line of that list won’t be prone to extensive runtime due to alphabetical ordering. Hopefully that will speed things up a bit.\nNext we need to take a quick look at LUKS partitions. Luckily for us, LUKS stores the encryption key in its header, which can be used independently from the rest of the partition.\nSo lets quickly create a small (128MB+Header) LUKS container which we can use to test our little script:\n$ dd if=/dev/urandom of=luks_container.img bs=1M count=128 $ cryptsetup --verify-passphrase luksFormat luks_container.img WARNING! ======== This will overwrite data on luks_container.img irrevocably. Are you sure? (Type 'yes' in capital letters): YES Enter passphrase for luks_container.img: Verify passphrase: In my case I chose the words from line 100 of the password file as passphrase:\n$ head -n 100 passwords | tail -n 1 march scoff deck large drove wavy jet crush We can now non-interactively check for the password and get a return code of 0 in case of success and 2 in case of the wrong password:\n$ echo \"march scoff deck large drove wavy jet crush\" | cryptsetup luksOpen --test-passphrase luks_container.img $ echo $? 0 $ echo \"not the password!\" | cryptsetup luksOpen --test-passphrase luks_container.img No key available with this passphrase. $ echo $? 2 Now lets detach the LUKS container header:\n$ cryptsetup luksHeaderBackup --header-backup-file luks_container_header luks_container.img $ ls -lah Permissions Size User Date Modified Name ... .rw-r--r-- 134M tiwa 3 Nov 19:18 luks_container.img .r-------- 17M tiwa 3 Nov 19:22 luks_container_header ... At this point we are left with a 17MB header file, which we can use independently from the encrypted data to check for the password. The header behaves exactly like the LUKS container:\n$ echo \"march scoff deck large drove wavy jet crush\" | cryptsetup luksOpen --test-passphrase luks_container_header $ echo $? 0 $ echo \"not the password!\" | cryptsetup luksOpen --test-passphrase luks_container_header No key available with this passphrase. $ echo $? 2 Bruteforcing the password is quite easily done with a simple loop:\nstart_time=$(date +%s) line_number=0 while IFS= read -r line; do ((line_number += 1)) echo $line_number \u003e progress echo \"$line\" | cryptsetup luksOpen --test-passphrase luks_container_header return_code=$? if [ $return_code -eq 0 ]; then end_time=$(date +%s) runtime=$((end_time - start_time)) formatted_runtime=$(date -u -d @$runtime +'%H:%M:%S') echo \"Total runtime : $formatted_runtime\" \u003e\u003e result echo \"PASSPHRASE : $line\" \u003e\u003e result exit 0 elif [ $return_code -eq 2 ]; then continue fi done \u003c passwords Running the script with the correct password in line 100 took about 4min on my laptop:\nTotal runtime : 00:03:58 PASSPHRASE : march scoff deck large drove wavy jet crush Now lets add parallel into the mix, a tool, which can run bash functions concurrently on their input. On NixOS we can simply use nix-shell to grab a version of it:\n$ nix-shell -p parallel ... $ parallel --help Usage: parallel [options] [command [arguments]] \u003c list_of_arguments parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))... cat ... | parallel --pipe [options] [command [arguments]] ... From there we just need to rewrite our code to use a function instead of a while loop and then use parallel in order to input the passphrases line by line.\nstart_time=$(date +%s) check_passphrase() { start_time=\"$1\" line=\"${@: -1}\" echo \"$line\" | cryptsetup luksOpen --test-passphrase luks_container_header return_code=$? echo -n '.' \u003e\u003e progress if [ $return_code -eq 0 ]; then end_time=$(date +%s) runtime=$((end_time - start_time)) formatted_runtime=$(date -u -d @$runtime +'%H:%M:%S') echo \"Total runtime : $formatted_runtime\" \u003e\u003e result echo \"PASSPHRASE : $line\" \u003e\u003e result exit 1 fi } export -f check_passphrase parallel --halt 1 --line-buffer -a passwords check_passphrase $start_time Using parallel the script ran only a tiny bit faster, which initially did not look too impressive for a speedup:\nTotal runtime : 00:03:52 PASSPHRASE : march scoff deck large drove wavy jet crush However my laptop only has 4 cores, whereas my desktop for example has 12 all of which are a bit more powerful, there already the speedup is quite significant already almost cutting the time it took to find the password in half:\n$ cat result # without parallel Total runtime : 00:04:15 PASSPHRASE : march scoff deck large drove wavy jet crush $ cat result # with parallel Total runtime : 00:01:46 PASSPHRASE : march scoff deck large drove wavy jet crush In conclusion, given with access to multiple machines (and by splitting up the password list in a way that makes sense), it is probably possible to get ahold of the password in time.\nIf something should go wrong we can even recover the progress by looking into the ./progress file, counting the dots and removing as many lines from the password list.\n","wordCount":"1476","inLanguage":"en","datePublished":"2023-11-03T00:00:00Z","dateModified":"2023-11-03T00:00:00Z","author":[{"@type":"Person","name":"oblivious observer"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://oblivious.observer/posts/recovering-a-lost-password/"},"publisher":{"@type":"Organization","name":"oblivious observer","logo":{"@type":"ImageObject","url":"https://oblivious.observer/observer-16x16.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oblivious.observer accesskey=h title="  (Alt + H)"><img src=https://oblivious.observer/observer-64x64.png alt aria-label=logo height=35></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://oblivious.observer/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://oblivious.observer/posts/ title=posts><span>posts</span></a></li><li><a href=https://oblivious.observer/archives/ title=archive><span>archive</span></a></li><li><a href=https://oblivious.observer/tags/ title=tags><span>tags</span></a></li><li><a href=https://oblivious.observer/index.html title=about><span>about</span></a></li><li><a href=https://oblivious.observer/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Recovering a forgotten LUKS password</h1><div class=post-meta><span title='2023-11-03 00:00:00 +0000 UTC'>November 3, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;oblivious observer</div></header><div class=post-content><p>A friend of mine just forgot the fulldisk encryption password for a laptop.. sounds like a fun little adventure!</p><p>This is not exactly a new topic, there are nice posts about this problem such as <a href=https://www.nmattia.com/posts/2017-03-05-crack-luks-stutter-gnu-parallel/>this one</a>, however this is how I&rsquo;ve tried to tackle the problem.</p><p>The password was generated according to a couple of rules and only partially lost.</p><p>Lets assume here for the sake of this little post that the password was generated by using a word list and contained multiple words, some of which are missing.</p><p>Lets build ourselves a little prototype:</p><p>First let&rsquo;s grab a wordlist, in this case lets grab a copy of the EFFs short word list from <a href=https://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt>here</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ wget https://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt
</span></span><span style=display:flex><span>--2023-11-03 18:34:27--  https://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt
</span></span><span style=display:flex><span>Resolving www.eff.org <span style=color:#ff79c6>(</span>www.eff.org<span style=color:#ff79c6>)</span>... 2a04:4e42:8d::201, 146.75.116.201
</span></span><span style=display:flex><span>Connecting to www.eff.org <span style=color:#ff79c6>(</span>www.eff.org<span style=color:#ff79c6>)</span>|2a04:4e42:8d::201|:443... connected.
</span></span><span style=display:flex><span>HTTP request sent, awaiting response... <span style=color:#bd93f9>200</span> OK
</span></span><span style=display:flex><span>Length: <span style=color:#bd93f9>13660</span> <span style=color:#ff79c6>(</span>13K<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>[</span>text/plain<span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>Saving to: ‘eff_short_wordlist_1.txt’
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eff_short_wordlist_1.txt                        100%<span style=color:#ff79c6>[====================================================================================================</span>&gt;<span style=color:#ff79c6>]</span>  13.34K  --.-KB/s    in 0.002s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2023-11-03 18:34:28 <span style=color:#ff79c6>(</span>6.58 MB/s<span style=color:#ff79c6>)</span> - ‘eff_short_wordlist_1.txt’ saved <span style=color:#ff79c6>[</span>13660/13660<span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ head eff_short_wordlist_1.txt
</span></span><span style=display:flex><span><span style=color:#bd93f9>1111</span>    acid
</span></span><span style=display:flex><span><span style=color:#bd93f9>1112</span>    acorn
</span></span><span style=display:flex><span><span style=color:#bd93f9>1113</span>    acre
</span></span><span style=display:flex><span><span style=color:#bd93f9>1114</span>    acts
</span></span><span style=display:flex><span><span style=color:#bd93f9>1115</span>    afar
</span></span><span style=display:flex><span><span style=color:#bd93f9>1116</span>    affix
</span></span><span style=display:flex><span><span style=color:#bd93f9>1121</span>    aged
</span></span><span style=display:flex><span><span style=color:#bd93f9>1122</span>    agent
</span></span><span style=display:flex><span><span style=color:#bd93f9>1123</span>    agile
</span></span><span style=display:flex><span><span style=color:#bd93f9>1124</span>    aging
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat wordlist.txt | wc -l
</span></span><span style=display:flex><span><span style=color:#bd93f9>1296</span>
</span></span></code></pre></div><p>Taking a look at the wordlist, we can see it contains two columns and is 1.3k lines long, since we are only interested in the words itself and this is an example, lets create a new shorter wordlist file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ shuf -n <span style=color:#bd93f9>100</span> eff_short_wordlist_1.txt | sort | cut -f 2- &gt; wordlist.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ head wordlist.txt
</span></span><span style=display:flex><span>aloft
</span></span><span style=display:flex><span>arson
</span></span><span style=display:flex><span>bagel
</span></span><span style=display:flex><span>bunny
</span></span><span style=display:flex><span>cache
</span></span><span style=display:flex><span>cheer
</span></span><span style=display:flex><span>cleat
</span></span><span style=display:flex><span>clump
</span></span><span style=display:flex><span>comma
</span></span><span style=display:flex><span>crush
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat wordlist.txt | wc -l
</span></span><span style=display:flex><span><span style=color:#bd93f9>100</span>
</span></span></code></pre></div><p>Now lets generate a file containing all possible passwords according to what we know. We have a couple of words we know and are missing two of them, but we know the positions of the missing words.</p><p>Lets grab a couple of words start with so we can generate a test password:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ shuf -n <span style=color:#bd93f9>6</span> wordlist.txt
</span></span><span style=display:flex><span>march
</span></span><span style=display:flex><span>scoff
</span></span><span style=display:flex><span>large
</span></span><span style=display:flex><span>drove
</span></span><span style=display:flex><span>wavy
</span></span><span style=display:flex><span>crush
</span></span></code></pre></div><p>So lets assume our password is the following string with <code>X</code> and <code>Y</code> being the missing words:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>march scoff X large drove wavy Y crush
</span></span></code></pre></div><p>Based on this we can quickly generate a list of possible passwords from the wordlist:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>input_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;march scoff X large drove wavy Y crush&#34;</span>
</span></span><span style=display:flex><span>readarray -t words &lt; wordlist.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> word_x in <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>words</span>[@]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>; <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> word_y in <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>words</span>[@]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>; <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>replaced_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>input_string</span>/X/<span style=color:#8be9fd;font-style:italic>$word_x</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>replaced_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>replaced_string</span>/Y/<span style=color:#8be9fd;font-style:italic>$word_y</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$replaced_string</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>done</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>done</span> &gt; password_list
</span></span></code></pre></div><p>This gives us a list with 10000 possible combnations for passphrases.</p><p>However we can probably assume, that the forgotten passphrase does not contain the same two words twice, so lets cut it down a bit further:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>input_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;march scoff X large drove wavy Y crush&#34;</span>
</span></span><span style=display:flex><span>readarray -t words &lt; wordlist.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> word_x in <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>words</span>[@]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>; <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> word_y in <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>words</span>[@]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>; <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>replaced_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>input_string</span>/X/<span style=color:#8be9fd;font-style:italic>$word_x</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>replaced_string</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>replaced_string</span>/Y/<span style=color:#8be9fd;font-style:italic>$word_y</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>[[</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$word_x</span><span style=color:#f1fa8c>&#34;</span> !<span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$word_y</span><span style=color:#f1fa8c>&#34;</span> <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$input_string</span><span style=color:#f1fa8c>&#34;</span> !<span style=color:#ff79c6>=</span> *<span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$word_x</span><span style=color:#f1fa8c>&#34;</span>* <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$input_string</span><span style=color:#f1fa8c>&#34;</span> !<span style=color:#ff79c6>=</span> *<span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$word_y</span><span style=color:#f1fa8c>&#34;</span>* <span style=color:#ff79c6>]]</span>; <span style=color:#ff79c6>then</span>
</span></span><span style=display:flex><span>      <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$replaced_string</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>done</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>done</span> &gt; password_list
</span></span></code></pre></div><p>This way we end up with only 8742 possible words, so we have already eliminated ~13% of possible passwords, nice.</p><p>At this point we&rsquo;ve generated every possible combination that makes sense to check, however the word list still looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ head password_list
</span></span><span style=display:flex><span>march scoff aloft large drove wavy arson crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy bagel crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy bunny crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy cache crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy cheer crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy cleat crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy clump crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy comma crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy cycle crush
</span></span><span style=display:flex><span>march scoff aloft large drove wavy dab crush
</span></span></code></pre></div><p>Lets add some randomness into the mix by shuffling the order around:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ shuf password_list &gt; passwords
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ head passwords
</span></span><span style=display:flex><span>march scoff thud large drove wavy icon crush
</span></span><span style=display:flex><span>march scoff deck large drove wavy slimy crush
</span></span><span style=display:flex><span>march scoff said large drove wavy slept crush
</span></span><span style=display:flex><span>march scoff jet large drove wavy snap crush
</span></span><span style=display:flex><span>march scoff penny large drove wavy fiber crush
</span></span><span style=display:flex><span>march scoff decoy large drove wavy slept crush
</span></span><span style=display:flex><span>march scoff wipe large drove wavy spoon crush
</span></span><span style=display:flex><span>march scoff clump large drove wavy recap crush
</span></span><span style=display:flex><span>march scoff deck large drove wavy fiber crush
</span></span><span style=display:flex><span>march scoff said large drove wavy radar crush
</span></span></code></pre></div><p>This looks way better already, now a script running through every line of that list won&rsquo;t be prone to extensive runtime due to alphabetical ordering. Hopefully that will speed things up a bit.</p><p>Next we need to take a quick look at LUKS partitions. Luckily for us, LUKS stores the encryption key in its header, which can be used independently from the rest of the partition.</p><p>So lets quickly create a small (128MB+Header) LUKS container which we can use to test our little script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ dd <span style=color:#ff79c6>if</span><span style=color:#ff79c6>=</span>/dev/urandom <span style=color:#8be9fd;font-style:italic>of</span><span style=color:#ff79c6>=</span>luks_container.img <span style=color:#8be9fd;font-style:italic>bs</span><span style=color:#ff79c6>=</span>1M <span style=color:#8be9fd;font-style:italic>count</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>128</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cryptsetup --verify-passphrase luksFormat luks_container.img
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WARNING!
</span></span><span style=display:flex><span><span style=color:#ff79c6>========</span>
</span></span><span style=display:flex><span>This will overwrite data on luks_container.img irrevocably.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Are you sure? <span style=color:#ff79c6>(</span>Type <span style=color:#f1fa8c>&#39;yes&#39;</span> in capital letters<span style=color:#ff79c6>)</span>: YES
</span></span><span style=display:flex><span>Enter passphrase <span style=color:#ff79c6>for</span> luks_container.img:
</span></span><span style=display:flex><span>Verify passphrase:
</span></span></code></pre></div><p>In my case I chose the words from line 100 of the password file as passphrase:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ head -n <span style=color:#bd93f9>100</span> passwords | tail -n <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>march scoff deck large drove wavy jet crush
</span></span></code></pre></div><p>We can now non-interactively check for the password and get a return code of 0 in case of success and 2 in case of the wrong password:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;march scoff deck large drove wavy jet crush&#34;</span> | cryptsetup luksOpen --test-passphrase luks_container.img
</span></span><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$?</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;not the password!&#34;</span> | cryptsetup luksOpen --test-passphrase luks_container.img
</span></span><span style=display:flex><span>No key available with this passphrase.
</span></span><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$?</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span>
</span></span></code></pre></div><p>Now lets detach the LUKS container header:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cryptsetup luksHeaderBackup --header-backup-file luks_container_header luks_container.img
</span></span><span style=display:flex><span>$ ls -lah
</span></span><span style=display:flex><span>Permissions Size User Date Modified Name
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>.rw-r--r--  134M tiwa  <span style=color:#bd93f9>3</span> Nov 19:18  luks_container.img
</span></span><span style=display:flex><span>.r--------   17M tiwa  <span style=color:#bd93f9>3</span> Nov 19:22  luks_container_header
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>At this point we are left with a 17MB header file, which we can use independently from the encrypted data to check for the password. The header behaves exactly like the LUKS container:</p><pre tabindex=0><code class=language-nil data-lang=nil>$ echo &#34;march scoff deck large drove wavy jet crush&#34; | cryptsetup luksOpen --test-passphrase luks_container_header
$ echo $?
0

$ echo &#34;not the password!&#34; | cryptsetup luksOpen --test-passphrase luks_container_header
No key available with this passphrase.
$ echo $?
2
</code></pre><p>Bruteforcing the password is quite easily done with a simple loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>start_time</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date +%s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>line_number</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span> <span style=color:#8be9fd;font-style:italic>IFS</span><span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>read</span> -r line; <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>((</span><span style=color:#8be9fd;font-style:italic>line_number</span> <span style=color:#ff79c6>+=</span> 1<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$line_number</span> &gt; progress
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$line</span><span style=color:#f1fa8c>&#34;</span> | cryptsetup luksOpen --test-passphrase luks_container_header
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>return_code</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>$?</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>[</span> <span style=color:#8be9fd;font-style:italic>$return_code</span> -eq <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>]</span>; <span style=color:#ff79c6>then</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>end_time</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date +%s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>runtime</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$((</span>end_time <span style=color:#ff79c6>-</span> start_time<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>formatted_runtime</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date -u -d @<span style=color:#8be9fd;font-style:italic>$runtime</span> +<span style=color:#f1fa8c>&#39;%H:%M:%S&#39;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;Total runtime : </span><span style=color:#8be9fd;font-style:italic>$formatted_runtime</span><span style=color:#f1fa8c>&#34;</span> &gt;&gt; result
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;PASSPHRASE    : </span><span style=color:#8be9fd;font-style:italic>$line</span><span style=color:#f1fa8c>&#34;</span> &gt;&gt; result
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>exit</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>elif</span> <span style=color:#ff79c6>[</span> <span style=color:#8be9fd;font-style:italic>$return_code</span> -eq <span style=color:#bd93f9>2</span> <span style=color:#ff79c6>]</span>; <span style=color:#ff79c6>then</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>fi</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>done</span> &lt; passwords
</span></span></code></pre></div><p>Running the script with the correct password in line 100 took about 4min on my laptop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Total runtime : 00:03:58
</span></span><span style=display:flex><span>PASSPHRASE    : march scoff deck large drove wavy jet crush
</span></span></code></pre></div><p>Now lets add <code>parallel</code> into the mix, a tool, which can run bash functions concurrently on their input. On NixOS we can simply use nix-shell to grab a version of it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ nix-shell -p parallel
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>$ parallel --help
</span></span><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parallel <span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>command</span> <span style=color:#ff79c6>[</span>arguments<span style=color:#ff79c6>]]</span> &lt; list_of_arguments
</span></span><span style=display:flex><span>parallel <span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>command</span> <span style=color:#ff79c6>[</span>arguments<span style=color:#ff79c6>]]</span> <span style=color:#ff79c6>(</span>::: arguments|:::: argfile<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>))</span>...
</span></span><span style=display:flex><span>cat ... | parallel --pipe <span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>command</span> <span style=color:#ff79c6>[</span>arguments<span style=color:#ff79c6>]]</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>From there we just need to rewrite our code to use a function instead of a while loop and then use <code>parallel</code> in order to input the passphrases line by line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>start_time</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date +%s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>check_passphrase<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>start_time</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$1</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>line</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span>@: -1<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#8be9fd;font-style:italic>$line</span><span style=color:#f1fa8c>&#34;</span> | cryptsetup luksOpen --test-passphrase luks_container_header
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>return_code</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>$?</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>echo</span> -n <span style=color:#f1fa8c>&#39;.&#39;</span> &gt;&gt; progress
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>[</span> <span style=color:#8be9fd;font-style:italic>$return_code</span> -eq <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>]</span>; <span style=color:#ff79c6>then</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>end_time</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date +%s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>runtime</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$((</span>end_time <span style=color:#ff79c6>-</span> start_time<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>formatted_runtime</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>date -u -d @<span style=color:#8be9fd;font-style:italic>$runtime</span> +<span style=color:#f1fa8c>&#39;%H:%M:%S&#39;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;Total runtime : </span><span style=color:#8be9fd;font-style:italic>$formatted_runtime</span><span style=color:#f1fa8c>&#34;</span> &gt;&gt; result
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;PASSPHRASE    : </span><span style=color:#8be9fd;font-style:italic>$line</span><span style=color:#f1fa8c>&#34;</span> &gt;&gt; result
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>exit</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>fi</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>export</span> -f check_passphrase
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parallel --halt <span style=color:#bd93f9>1</span> --line-buffer -a passwords check_passphrase <span style=color:#8be9fd;font-style:italic>$start_time</span>
</span></span></code></pre></div><p>Using <code>parallel</code> the script ran only a tiny bit faster, which initially did not look too impressive for a speedup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Total runtime : 00:03:52
</span></span><span style=display:flex><span>PASSPHRASE    : march scoff deck large drove wavy jet crush
</span></span></code></pre></div><p>However my laptop only has 4 cores, whereas my desktop for example has 12 all of which are a bit more powerful, there already the speedup is quite significant already almost cutting the time it took to find the password in half:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat result <span style=color:#6272a4># without parallel</span>
</span></span><span style=display:flex><span>Total runtime : 00:04:15
</span></span><span style=display:flex><span>PASSPHRASE    : march scoff deck large drove wavy jet crush
</span></span><span style=display:flex><span>$ cat result <span style=color:#6272a4># with parallel</span>
</span></span><span style=display:flex><span>Total runtime : 00:01:46
</span></span><span style=display:flex><span>PASSPHRASE    : march scoff deck large drove wavy jet crush
</span></span></code></pre></div><p>In conclusion, given with access to multiple machines (and by splitting up the password list in a way that makes sense), it is probably possible to get ahold of the password in time.</p><p>If something should go wrong we can even recover the progress by looking into the <code>./progress</code> file, counting the dots and removing as many lines from the password list.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://oblivious.observer/tags/nixos/>NixOS</a></li><li><a href=https://oblivious.observer/tags/luks/>LUKS</a></li><li><a href=https://oblivious.observer/tags/bash/>bash</a></li></ul></footer><script src=https://utteranc.es/client.js repo=observer/observer.github.io issue-term=url label=💬 theme=photon-dark crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>